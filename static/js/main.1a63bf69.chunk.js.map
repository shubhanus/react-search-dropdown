{"version":3,"sources":["components/Results/HighlightedText.js","components/Results/UserCard.js","components/Results/index.js","hooks/search.js","utils/scroll.js","hooks/optionSelect.js","components/Input/index.js","App.js","serviceWorker.js","index.js"],"names":["React","memo","_ref","children","query","RegExp","concat","test","react_default","a","createElement","Fragment","className","substring","length","props","nextProps","UserCard","forwardRef","ref","id","name","address","isHover","inItems","onMouseOver","undefined","Results_HighlightedText","_ref$options","options","focused","handelHover","focusedOptionRef","listRef","map","option","index","Results_UserCard","Object","assign","key","useSearch","data","_useState","useState","_useState2","slicedToArray","searchValue","setSearchValue","_useState3","_useState4","isMenuOpen","setMenuOpen","searchOptions","useMemo","re","nextRes","i","_data$i","items","find","item","toLowerCase","push","objectSpread","handelSearch","target","value","closeMenu","scrollTo","scrollElement","top","current","scrollTop","useOptionSelection","allowMenuScroll","useRef","blockHover","setFocused","focusOption","direction","nextFocusIndex","focusedIndex","useEffect","menuElement","menuItemElement","menuItemRect","getBoundingClientRect","menuRect","overScroll","offsetHeight","bottom","Math","min","offsetTop","clientHeight","scrollHeight","max","scrollIntoView","handelKeyDown","e","preventDefault","onMouseMove","resetFocused","MagnifyIcon_default","size","type","placeholder","onChange","CloseIcon_default","onClick","App","_useSearch","_useOptionSelection","handelBackdrop","useCallback","contains","document","addEventListener","removeEventListener","onKeyDown","components_Input","components_Results","Boolean","window","location","hostname","match","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1a63bf69.chunk.js","sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\n\n/**\n * This is react Stateless component\n * it highlightes searched keyword in rendered part if found else same string\n * All other updates apart form {children, query} change are blocked\n * @param {*} { children, query }\n * @returns ReactComponent\n */\nfunction HighlightedText({ children, query }) {\n  if (query) {\n    let re = new RegExp(`^(${query}).*$`, \"i\");\n    let searchKeywordIdx = re.test(children);\n    if (searchKeywordIdx) {\n      return (\n        <>\n          <b className=\"highlight\">{children.substring(0, query.length)}</b>\n          {children.substring(query.length)}\n        </>\n      );\n    }\n  }\n  return children;\n}\n\nHighlightedText.propTypes = {\n  children: PropTypes.string.isRequired,\n  query: PropTypes.string\n};\n\nconst areEqual = (props, nextProps) => {\n  if (\n    props.children === nextProps.children &&\n    props.query === nextProps.query\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport default React.memo(HighlightedText, areEqual);\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport HighlightedText from \"./HighlightedText\";\n/**\n * This React Stateless component\n * Renders User card with id, name, address, and if something found in items\n * This Component takes forwareded ref and set to list item when it is focused\n * Only updates when {id, name, address, isHover, query, inItems } changes\n * All Other Updates are blocked\n * @param {Object} {id, name, address, isHover, query, inItems, onMouseOver}\n * @returns ReactComponent\n */\nconst UserCard = React.forwardRef((props, ref) => {\n  const { id, name, address, isHover, query, inItems, onMouseOver } = props;\n  const handelMouseOver = () => {\n    onMouseOver(props);\n  };\n  return (\n    <li\n      ref={isHover ? ref : undefined}\n      className={`user__card ${isHover ? \"focused\" : \"\"}`}\n      onMouseOver={handelMouseOver}\n      // onMouseMove={}\n    >\n      <div className=\"user__card-id\">\n        <HighlightedText query={query}>{id}</HighlightedText>\n      </div>\n      {inItems && (\n        <div className=\"user__card-in-items\">\"{inItems}\" Found in items</div>\n      )}\n      <div className=\"user__card-name\">\n        <i>\n          <HighlightedText query={query}>{name}</HighlightedText>\n        </i>\n      </div>\n      <div className=\"user__card-address\">\n        <HighlightedText query={query}>{address}</HighlightedText>\n      </div>\n    </li>\n  );\n});\n\nUserCard.propTypes = {\n  id: PropTypes.string.isRequired,\n  name: PropTypes.string.isRequired,\n  address: PropTypes.string.isRequired,\n  isHover: PropTypes.bool.isRequired,\n  query: PropTypes.string,\n  inItems: PropTypes.string,\n  onMouseOver: PropTypes.func\n};\n\nconst areEqual = (props, nextProps) => {\n  if (\n    props.id === nextProps.id &&\n    props.name === nextProps.name &&\n    props.address === nextProps.address &&\n    props.isHover === nextProps.isHover &&\n    props.query === nextProps.query &&\n    props.inItems === nextProps.inItems\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport default React.memo(UserCard, areEqual);\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport UserCard from \"./UserCard\";\n/**\n * This is React Stateless component\n * Renders Menu and loop through Menu items\n * @param {Object} {\n *   options,\n *   query,\n *   focused,\n *   handelHover,\n *   focusedOptionRef,\n *   listRef\n * }\n * @returns ReactComponent\n */\nfunction Results({\n  options = [],\n  query,\n  focused,\n  handelHover,\n  focusedOptionRef,\n  listRef\n}) {\n  return (\n    <ul className=\"user__list\" ref={listRef}>\n      {options.length ? (\n        options.map((option, index) => (\n          <UserCard\n            {...option}\n            isHover={focused.id === option.id}\n            key={option.id}\n            query={query}\n            onMouseOver={handelHover}\n            index={index}\n            ref={focusedOptionRef}\n          />\n        ))\n      ) : (\n        <div className=\"user__card-empty\">No Users Found</div>\n      )}\n    </ul>\n  );\n}\n\nResults.propTypes = {\n  options: PropTypes.array.isRequired,\n  query: PropTypes.string.isRequired,\n  focused: PropTypes.object.isRequired,\n  handelHover: PropTypes.func.isRequired,\n  focusedOptionRef: PropTypes.object,\n  listRef: PropTypes.object\n};\n\nexport default React.memo(Results);\n","import { useState, useMemo } from \"react\";\n/**\n * This is React Custom hook\n * it takes all users object\n * handels searching, menu open close\n * @param {Array} data - User Array\n * @returns  { searchOptions, searchValue, handelSearch, isMenuOpen, closeMenu }\n */\nfunction useSearch(data) {\n  const [searchValue, setSearchValue] = useState(\"\");\n  const [isMenuOpen, setMenuOpen] = useState(false);\n\n  /**\n   * This function will perform search on data or search keyword\n   * @returns { searchOptions } - Memorized options will be returned\n   */\n  const searchOptions = useMemo(() => {\n    let re = new RegExp(`^(${searchValue}).*$`, \"i\");\n    const nextRes = [];\n    for (let i = 0; i < data.length; i++) {\n      const { id, name, address, items } = data[i];\n      const inItems = items.find(\n        item => item.toLowerCase() === searchValue.toLowerCase()\n      );\n      if (re.test(id) || re.test(name) || re.test(address) || inItems) {\n        if (inItems) {\n          nextRes.push({ ...data[i], inItems: inItems });\n        } else {\n          nextRes.push(data[i]);\n        }\n      }\n    }\n    return nextRes;\n  }, [data, searchValue]);\n\n  /**\n   * This medthod updates search keywords in state\n   * Function also handles menu open and close\n   */\n  const handelSearch = ({ target }) => {\n    setSearchValue(target.value);\n    if (isMenuOpen && !target.value) {\n      setMenuOpen(false);\n    } else if (!isMenuOpen && target.value) {\n      setMenuOpen(true);\n    }\n  };\n\n  /**\n   * This method change menu open state to close\n   */\n  const closeMenu = () => {\n    if (isMenuOpen) {\n      setMenuOpen(false);\n    }\n  };\n  return { searchOptions, searchValue, handelSearch, isMenuOpen, closeMenu };\n}\n\nexport default useSearch;\n","/**\n * This Method will set scroll value to element provided\n * @param {Element} el - any dom element\n * @param {Number} top - scroll value\n */\nfunction scrollTo(scrollElement, top) {\n  scrollElement.current.scrollTop = top;\n}\n\n/**\n * This method calculates provided menu element with menu item (focused) and scrolls menu up down\n * @export\n * @param {Element} menuElement - menu dom node\n * @param {Element} menuItemElement - menu item dom node\n */\nexport function scrollIntoView(menuElement, menuItemElement) {\n  const menuItemRect = menuItemElement.current.getBoundingClientRect();\n  const menuRect = menuElement.current.getBoundingClientRect();\n  const overScroll = menuItemElement.current.offsetHeight / 3;\n  if (menuItemRect.bottom + overScroll > menuRect.bottom) {\n    // next of last visible element available\n    // scroll down\n    scrollTo(\n      menuElement,\n      Math.min(\n        menuItemElement.current.offsetTop +\n          menuItemElement.current.clientHeight -\n          menuElement.current.offsetHeight +\n          overScroll,\n        menuElement.current.scrollHeight\n      )\n    );\n  } else if (menuItemRect.top - overScroll < menuRect.top) {\n    // scroll up\n    scrollTo(\n      menuElement,\n      Math.max(menuItemElement.current.offsetTop - overScroll, 0)\n    );\n  }\n}\n","import { useState, useRef, useEffect } from \"react\";\nimport { scrollIntoView } from \"../utils/scroll\";\n\nconst useOptionSelection = ({\n  options,\n  listRef,\n  focusedOptionRef,\n  closeMenu\n}) => {\n  const allowMenuScroll = useRef(false);\n  const blockHover = useRef(false);\n  const [focused, setFocused] = useState({});\n  const onMouseMove = () => {\n    onMouseMove.current = false;\n  };\n  const handelHover = option => {\n    if (blockHover.current || option.id === focused.id) {\n      // when hover blocked (keyboard preference) or hovering on same option id\n      return;\n    }\n    // changing focus option\n    setFocused(option);\n  };\n\n  /**\n   * @typedef {\"up\" | \"down\"} MetricFormat\n   */\n  /**\n   * This method takes direction and change focused state\n   * @param {MetricFormat} direction\n   */\n  const focusOption = direction => {\n    let nextFocusIndex;\n    const focusedIndex = focused.index === undefined ? -1 : focused.index;\n    if (direction === \"up\") {\n      nextFocusIndex = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;\n    } else if (direction === \"down\") {\n      nextFocusIndex = (focusedIndex + 1) % options.length;\n    }\n    allowMenuScroll.current = true;\n    setFocused({\n      ...options[nextFocusIndex],\n      index: nextFocusIndex\n    });\n  };\n\n  useEffect(() => {\n    // change state of menual focus is allowed or not\n    // used for mouse kay keyboard pref\n    if (allowMenuScroll.current) {\n      scrollIntoView(listRef, focusedOptionRef);\n    }\n    allowMenuScroll.current = false;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [focused]);\n\n  const resetFocused = () => {\n    // resets focus\n    if (focused.id) {\n      setFocused({});\n    }\n  };\n  /**\n   * This method handels Arrow up | Arrow down | Escape key down\n   * @param {Event} e\n   */\n  const handelKeyDown = e => {\n    switch (e.key) {\n      case \"ArrowUp\":\n        e.preventDefault();\n        focusOption(\"up\");\n        break;\n      case \"ArrowDown\":\n        e.preventDefault();\n        focusOption(\"down\");\n        break;\n      case \"Escape\":\n        closeMenu();\n        break;\n      default:\n        break;\n    }\n  };\n\n  return {\n    focused,\n    handelKeyDown,\n    handelHover,\n    onMouseMove,\n    resetFocused\n  };\n};\n\nexport default useOptionSelection;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport MagnifyIcon from \"mdi-react/MagnifyIcon\";\nimport CloseIcon from \"mdi-react/CloseIcon\";\n/**\n * This is React functional Stateless Component\n * It will render input component\n * Only updates when value of input(value prop) changed\n * Updates are blocked for all other events\n * @param {Object} { handelSearch, value }\n * @returns {ReactComponent}\n */\nfunction Input({ handelSearch, value }) {\n  /**\n   * Clear input's value \n   */\n  const clearInput = () => {\n    handelSearch({ target: { value: \"\" } });\n  };\n  return (\n    <div className=\"input__wrapper\">\n      <MagnifyIcon size={20} className=\"magnify-ico\" />\n      <input\n        className=\"input__box\"\n        type=\"text\"\n        placeholder=\"Search users by ID, address, name\"\n        onChange={handelSearch}\n        value={value}\n      />\n      {value && (\n        <CloseIcon size={20} className=\"close-ico\" onClick={clearInput} />\n      )}\n    </div>\n  );\n}\n\nInput.propTypes = {\n  handelSearch: PropTypes.func.isRequired,\n  value: PropTypes.string\n};\n\nconst areEqual = (props, nextProps) => {\n  if (props.value !== nextProps.value) {\n    return false;\n  }\n  return true;\n};\n\nexport default React.memo(Input, areEqual);\n","import React, { useEffect, useRef, useCallback } from \"react\";\nimport data from \"./mockdata.json\";\nimport \"./App.scss\";\nimport Results from \"./components/Results/index.js\";\nimport useSearch from \"./hooks/search.js\";\nimport useOptionSelection from \"./hooks/optionSelect.js\";\nimport Input from \"./components/Input/index.js\";\n\nfunction App() {\n  const listRef = useRef(null);\n  const focusedOptionRef = useRef(null);\n  const {\n    searchOptions,\n    searchValue,\n    handelSearch,\n    isMenuOpen,\n    closeMenu\n  } = useSearch(data);\n\n  const {\n    focused,\n    handelKeyDown,\n    handelHover,\n    onMouseMove,\n    resetFocused\n  } = useOptionSelection({\n    options: searchOptions,\n    listRef,\n    focusedOptionRef,\n    closeMenu\n  });\n\n  useEffect(() => {\n    // while searching reset selected option\n    resetFocused();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchValue]);\n\n  /**\n   * This method detect outside click when menu is open and closes menu\n   */\n  const handelBackdrop = useCallback(\n    e => {\n      if (\n        (listRef.current && listRef.current.contains(e.target)) ||\n        e.target.className === \"input__box\"\n      ) {\n        return;\n      }\n      closeMenu();\n    },\n    [closeMenu, listRef]\n  );\n\n  /**\n   * This Effect registers and de-register mouse click(down) event\n   */\n  useEffect(() => {\n    if (isMenuOpen) {\n      document.addEventListener(\"mousedown\", handelBackdrop, false);\n    }\n    return () => {\n      document.removeEventListener(\"mousedown\", handelBackdrop, false);\n    };\n  }, [handelBackdrop, isMenuOpen]);\n\n  return (\n    <div onKeyDown={isMenuOpen ? handelKeyDown : undefined} className=\"root\">\n      <Input handelSearch={handelSearch} value={searchValue} />\n      {isMenuOpen && (\n        <Results\n          options={searchOptions}\n          query={searchValue}\n          focused={focused}\n          handelHover={handelHover}\n          onMouseMove={onMouseMove}\n          listRef={listRef}\n          focusedOptionRef={focusedOptionRef}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}